function  surface_parcellation_subcort_subsampled(cohortfile,tmasklist,outputdir)
%surface_parcellation(cohortfile,tmasklist,hems,[outputdir])
%
%Generate gradient-based parcellation on surface registered subject data
%
% This script requires a 'cohortfile' text file. The cohortfile includes
% a list of the subject names, the full path of the surface-mapped cifti
% functional data to be parcellated, and the directory where the subject's
% surface is (as generated by Freesurfer and registered to fs_LR space),
% formatted as:
%
% subjectname cifti surfdir
%
% e.g.
% vc33416 /data/cn4/laumannt/vc33416_BOLD_LR_surf_subcort_32k_fsLR_smooth2.55.dtseries.nii /data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/vc33416/7112b_fs_LR
%
% With 'tmasklist', users should specify a text file including a list of
% subject names and the full path to each subject's tmask file (a binary
% text file of length #timepoints indicating timepoints to include (1) or censor
% (0)). The tmasklist is formatted as:
%
% subjectname tmaskfile
%
% e.g.
% vc33416 /data/cn4/laumannt/vc33416_tmasklist.txt
%
% With 'hems', users can specify that either the 'LEFT', 'RIGHT', or 'BOTH'
% hemispheres be parcellated.
%
% 'outputdir' specifies the folder to write results into. Omit to write
% into the working directory.
%
% This version of surface parcellation will average gradient data across
% subjects to generate a mean gradient and edge map for the group.
%
%
% TOL 01/25/13, modified by EMG 04/03/15


% PARAMETERS TO SET
smooth = 2.55; % sigma for geodesic smoothing applied to gradient maps
workbenchdir = 'nice /data/cn4/laumannt/workbench_v1/bin_rh_linux64/'; %location of workbench
atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser'; % Location of atlas surface
subsample = 100;

%-----------------------------------------------------------------------


if ~exist('outputdir')
    outputdir = pwd;
end


% Read in subject names, functional volume locations, and surface directory
[subjects cifti_files] = textread(cohortfile,'%s%s');

% Read in tmasks
[tmasksubjects tmaskfiles]=textread(tmasklist,'%s%s');
if ~isequal(tmasksubjects,subjects)
    error('tmasklist subjects do not match cohortfile subjects');
end





% Make output folder
mkdir(outputdir)
cd(outputdir)


%Name of the altas midthickness surface
midsurf_32k_atlas = {[atlasdir '/fsaverage_LR32k/Conte69.L.midthickness.32k_fs_LR.surf.gii'],[atlasdir '/fsaverage_LR32k/Conte69.R.midthickness.32k_fs_LR.surf.gii']};


for s = 1:length(subjects)
    tic
    subject = subjects{s};
    surfdir = ['/data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/' subject '/7112b_fs_LR/'];
    %surfdirs{s};
    cifti_file = cifti_files{s};
    tmask = load(tmaskfiles{s});
    
    %Name of this subject's midthickness surface
    midsurf_32k_sub = {[surfdir '/fsaverage_LR32k/' subject '.L.midthickness.32k_fs_LR.surf.gii'],[surfdir '/fsaverage_LR32k/' subject '.R.midthickness.32k_fs_LR.surf.gii']};
    
    
    disp(['Processing subject #' num2str(s) ': ' subject])
    
    % Load cifti file
    ciftistruct = ft_read_cifti_mod(cifti_file);
    cifti_timecourse = ciftistruct.data;
    ciftistruct.data = [];
    ciftistruct_orig = ciftistruct;
    
    % Set up some values to be used across subjects
    if s==1
        ncortverts = nnz(ciftistruct.brainstructure==1)+nnz(ciftistruct.brainstructure==2);
        nsubcortverts = nnz(ciftistruct.brainstructure>2);
        num_samples = round(size(cifti_timecourse,1)/subsample);
        
        fullgrads = zeros(nsubcortverts,num_samples,'single');
        
        neighbors = cifti_neighbors(cifti_file);
        neighbors = neighbors(ncortverts+1:end,:);
        
        subcort_inds = (ciftistruct.brainstructure>2);
        ciftistruct_subcortonly = ciftistruct;
        ciftistruct_subcortonly.brainstructure = ciftistruct_subcortonly.brainstructure(subcort_inds);
        ciftistruct_subcortonly.brainstructure = ciftistruct_subcortonly.brainstructure-2;
        ciftistruct_subcortonly.brainstructure(ciftistruct_subcortonly.brainstructure<1) = -1;
        ciftistruct_subcortonly.pos = ciftistruct_subcortonly.pos(subcort_inds,:);
        ciftistruct_subcortonly.hdr.dim(6) = nsubcortverts;
        ciftistruct_subcortonly.brainstructurelabel = ciftistruct_subcortonly.brainstructurelabel(3:end);
        
        
    end
    
    
    % Calculate correlation maps
    disp('Calculating correlation map')
    cifti_corrmap = paircorr_mod(cifti_timecourse(:,logical(tmask))');
    clear cifti_timecourse
    
    % Remove NaNs (produced if vertices have no data)
    cifti_corrmap(isnan(cifti_corrmap)) = 0;
    % Apply the Fisher tranformation
    cifti_corrmap = single(FisherTransform(cifti_corrmap));
    
    randinds = randperm(size(cifti_corrmap,1));
    randinds = randinds(1:num_samples);
    
    % Calculate correlation similarity
    disp('Calculating similarity map')
    corrofcorr =paircorr_mod(cifti_corrmap(:,ncortverts+1:end),cifti_corrmap(:,randinds));
    clear cifti_corrmap
    
    % Remove NaNs
    corrofcorr(isnan(corrofcorr)) = 0;
    % Apply the Fisher tranformation
    corrofcorr = FisherTransform(corrofcorr);
    
    % Write out corr of corr cifti file for gradient calculation
    ciftistruct_subcortonly.data = corrofcorr;
    clear corrofcorr
    ft_write_cifti_mod([outputdir '/corrofcorr_subcort'],ciftistruct_subcortonly);
    ciftistruct_subcortonly.data = [];
    
    
    %         ciftistruct.brainstructure = ciftistruct.brainstructure(thishem_inds);
    %         ciftistruct.pos = ciftistruct.pos(thishem_inds,:);
    %         ciftistruct.hdr.dim(6:7) = size(corrofcorr);
    %         ciftistruct = rmfield(ciftistruct,'transform');
    %         ciftistruct = rmfield(ciftistruct,'dim');
    %         ciftistruct = rmfield(ciftistruct,'brainstructurelabel');
    %         ciftistruct.brainstructurelabel{1} = ['CORTEX_' hemname{hem}];
    %         ciftistruct.dimord = 'pos_pos';
    %         ciftistruct.data = corrofcorr;
    %         clear corrofcorr
    %         ft_write_cifti_mod(['corrofcorr_' HEMS{hem}],ciftistruct);
    %         ciftistruct.data = [];
        
    % Calculate gradients
    disp('Calculating gradient')
    gradsname = 'corrofcorr_allgrad_subcort';
    evalc(['!' workbenchdir '/wb_command -cifti-gradient ' outputdir '/corrofcorr_subcort.dtseries.nii COLUMN ' outputdir '/' gradsname '.dtseries.nii']);
    
    % Convert gradients and load
    grads = ft_read_cifti_mod([outputdir '/' gradsname '.dtseries.nii']);
    grads = single(grads.data);
    
    % Add subject gradients to running average
    fullgrads = fullgrads + grads;
    clear grads
    delete([outputdir '/corrofcorr_subcort.dtseries.nii'])
    delete([outputdir '/' gradsname '.dtseries.nii'])
    toc
end


%Average gradients across subjects
fullgrads = fullgrads./length(subjects);

%Save out average gradients
ciftistruct_subcortonly.data = fullgrads;
clear fullgrads
gradsname = 'avg_corrofcorr_allgrad_subcort';
ft_write_cifti_mod(gradsname,ciftistruct_subcortonly);
ciftistruct_subcortonly.data = [];


% Smooth gradients before edge detection
disp('Smoothing average gradient')
system([workbenchdir '/wb_command -cifti-smoothing ' outputdir '/' gradsname '.dtseries.nii ' num2str(smooth) ' 0 COLUMN ' outputdir '/' gradsname '_smooth' num2str(smooth) '.dtseries.nii']);

% Load smoothed gradients
ciftistruct = ft_read_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '.dtseries.nii']);

% Average smoothed gradients across maps (unused but useful to look at)
ciftistruct_subcortonly.data = mean(ciftistruct.data,2);
ft_write_cifti_orig([outputdir '/' gradsname '_smooth' num2str(smooth) 'avg'],ciftistruct_subcortonly);

fullgrads_smooth = ciftistruct.data;
ciftistruct.data = [];


disp('Calculating edges')

% Get local minima of each smoothed gradient map
minimametrics = metric_minima_all(fullgrads_smooth,3,neighbors);

% Run watershed-by-flooding algorithm on each gradient map to generate edges
edges = watershed_algorithm_all_par_cifti(fullgrads_smooth,minimametrics,200,1,neighbors);
clear fullgrads_smooth

% Average across gradient maps and save
edge_density = mean(edges==0,2);
ciftistruct_subcortonly.data = edge_density;
ft_write_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_avg'],ciftistruct_subcortonly);

% Save watershed edges from all gradient maps
ciftistruct_subcortonly.data = edges;
ft_write_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_all'],ciftistruct_subcortonly);
clear edges ciftistruct_orig

