function  surface_parcellation_bothhem_singlecorrmat(corrmatfile,templateciftifile,outputdir)
%surface_parcellation(cohortfile,tmasklist,hems,[outputdir])
%
%Generate gradient-based parcellation on surface registered subject data
%
% This script requires a 'cohortfile' text file. The cohortfile includes
% a list of the subject names, the full path of the surface-mapped cifti
% functional data to be parcellated, and the directory where the subject's
% surface is (as generated by Freesurfer and registered to fs_LR space),
% formatted as:
%
% subjectname cifti surfdir
%
% e.g.
% vc33416 /data/cn4/laumannt/vc33416_BOLD_LR_surf_subcort_32k_fsLR_smooth2.55.dtseries.nii /data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/vc33416/7112b_fs_LR
%
% With 'tmasklist', users should specify a text file including a list of
% subject names and the full path to each subject's tmask file (a binary
% text file of length #timepoints indicating timepoints to include (1) or censor
% (0)). The tmasklist is formatted as:
%
% subjectname tmaskfile
%
% e.g.
% vc33416 /data/cn4/laumannt/vc33416_tmasklist.txt
%
% With 'hems', users can specify that either the 'LEFT', 'RIGHT', or 'BOTH'
% hemispheres be parcellated.
%
% 'outputdir' specifies the folder to write results into. Omit to write
% into the working directory.
%
% This version of surface parcellation will average gradient data across
% subjects to generate a mean gradient and edge map for the group.
%
%
% TOL 01/25/13, modified by EMG 04/03/15


% PARAMETERS TO SET
smooth = 2.55; % sigma for geodesic smoothing applied to gradient maps
workbenchdir = 'nice /data/cn4/laumannt/workbench_v1/bin_rh_linux64/'; %location of workbench
atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser'; % Location of atlas surface

%-----------------------------------------------------------------------


if ~exist('outputdir')
    outputdir = pwd;
end





% Make output folder
mkdir(outputdir)
cd(outputdir)

ciftistruct = ft_read_cifti_mod(templateciftifile);
ciftistruct.data = [];
ciftistruct_orig = ciftistruct;

ncortverts = nnz(ciftistruct.brainstructure==1)+nnz(ciftistruct.brainstructure==2);

disp('Calculating cifti adjacencies')
neighbors = cifti_neighbors(templateciftifile);
neighbors = neighbors(1:ncortverts,:);

surface_inds = (ciftistruct.brainstructure<=2);
ciftistruct_surfonly = ciftistruct;
ciftistruct_surfonly.brainstructure = ciftistruct_surfonly.brainstructure(surface_inds);
ciftistruct_surfonly.pos = ciftistruct_surfonly.pos(surface_inds,:);
ciftistruct_surfonly.hdr.dim(6) = nnz((ciftistruct.brainstructure==1) | (ciftistruct.brainstructure==2));
ciftistruct_surfonly.brainstructurelabel = ciftistruct_surfonly.brainstructurelabel(1:2);
ciftistruct_surfonly = rmfield(ciftistruct_surfonly,'transform');
ciftistruct_surfonly = rmfield(ciftistruct_surfonly,'dim');


%Name of the altas midthickness surface
midsurf_32k_atlas = {[atlasdir '/fsaverage_LR32k/Conte69.L.midthickness.32k_fs_LR.surf.gii'],[atlasdir '/fsaverage_LR32k/Conte69.R.midthickness.32k_fs_LR.surf.gii']};

gradsname = 'corrofcorr_allgrad_LR';

disp('Loading data')
cifti_corrmap = ft_read_cifti_mod(corrmatfile);
cifti_corrmap = single(cifti_corrmap.data);

disp('Calculating similarity map')
corrofcorr =paircorr_mod(cifti_corrmap(:,1:ncortverts),cifti_corrmap);
clear cifti_corrmap
    
% Apply the Fisher tranformation
corrofcorr = FisherTransform(corrofcorr);
corrofcorr(isnan(corrofcorr)) = 0;

% Write out corr of corr cifti file for gradient calculation
ciftistruct_surfonly.data = corrofcorr;
clear corrofcorr
ft_write_cifti_mod('corrofcorr_LR',ciftistruct_surfonly);
ciftistruct_surfonly.data = [];

disp('Calculating gradient')
evalc(['!' workbenchdir '/wb_command -cifti-gradient ' outputdir '/corrofcorr_LR.dtseries.nii COLUMN ' outputdir '/' gradsname '.dtseries.nii -left-surface ' midsurf_32k_atlas{1} ' -right-surface ' midsurf_32k_atlas{2}]);

% Smooth gradients before edge detection
disp('Smoothing average gradient')
system([workbenchdir '/wb_command -cifti-smoothing ' outputdir '/' gradsname '.dtseries.nii ' num2str(smooth) ' 0 COLUMN ' outputdir '/' gradsname '_smooth' num2str(smooth) '.dtseries.nii -left-surface ' midsurf_32k_atlas{1} ' -right-surface ' midsurf_32k_atlas{2}]);

% Load smoothed gradients
ciftistruct = ft_read_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '.dtseries.nii']);

% Average smoothed gradients across maps (unused but useful to look at)
ciftistruct_surfonly.data = mean(ciftistruct.data,2);
ft_write_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) 'avg'],ciftistruct_surfonly);

fullgrads_smooth = ciftistruct.data;
ciftistruct.data = [];


disp('Calculating edges')

% Get local minima of each smoothed gradient map
minimametrics = metric_minima_all(fullgrads_smooth,3,neighbors);

% Run watershed-by-flooding algorithm on each gradient map to generate edges
labels = watershed_algorithm_all_par_cifti(fullgrads_smooth,minimametrics,200,1,neighbors);
clear fullgrads_smooth

% Average across gradient maps and save
labels_avg = mean(labels==0,2);
ciftistruct_surfonly.data = labels_avg;
ft_write_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_avg'],ciftistruct_surfonly);

% Save watershed edges from all gradient maps
ciftistruct_surfonly.data = labels;
ft_write_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_all'],ciftistruct_surfonly);
clear ciftistruct_orig labels

