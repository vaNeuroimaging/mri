function  surface_parcellation_inmask(cohortfile,outputdir,tmasktype,smooth,hems,edges,maskfile)
%Generate gradient-based parcellation on surface registered subject data
% This script requires a parcellation cohortfile file. The cohortfile includes
% a list of the subject names, the functional volume to be parcellated including
% its path, and the directory where the subject's surface is (as generated by 
% Freesurfer and registered to fs_LR space), formatted as:
% 
% subjectname funcpath/funcvol surfdir
% 
% e.g. 
%
% vc33416 /data/cn4/laumannt/vc33416_rest1.4dfp.img /data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/vc33416/7112b_fs_LR
%
% With 'tmasktype', users can enter a tmasklist.txt as created by
% fcimage_analysis to mask out timepoints in their data. Enter 'none' if no
% temporal mask is needed.
% If 'smooth' is set to  'yes' data will be smoothed along the cortical
% surface after surface projection. Enter 'no' if no surface smoothing is
% desired.
% With 'hems', users can specify that either the 'LEFT', 'RIGHT', or 'BOTH'
% hemispheres be parcellated.
% If 'edges' is set to 'yes' a final non-maxima suppression step will be
% applied to the gradient maps and an edge frequency map will be output in
% addition to an average gradient map. Enter 'no' if edge detection is not
% desired.
% This version of surface parcellation will always average correlation data
% from all subjects, generating a single gradient and/or edge map for the
% group.
%Run on tsunami
%matlab12
%addpath /data/cn4/laumannt/assignment_problem_v2/Scripts/
%addpath /data/cn4/laumannt/surface_gradient_code/
%outputdir - full path

% TOL 01/25/13

smoothnum = 2.55;
mask4dfp='/data/cn4/laumannt/Standard/glm_atlas_mask_333.4dfp.img';
workbenchdir = '/data/cn4/laumannt/workbench/bin_linux64/';
HEMS = {'L';'R'};
hemname = {'LEFT';'RIGHT'};

[ign subnum] = system(['cat ' cohortfile ' | wc -l']);
subnum = str2num(subnum);

% Read in subject names, functional volume locations, and surface directory
for s = 1:subnum
[ign subjects{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $1}'' ' cohortfile]);
[ign funcpaths{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $2}'' ' cohortfile ' | awk -F ''/'' ''sub(FS $NF,x)''']);
[ign funcvols{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $2}'' ' cohortfile ' | awk -F ''/'' ''{print $NF}'' | awk -F ''.'' ''{print $1}''']);
[ign surfdirs{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $3}'' ' cohortfile]);
end

% Check masktype and the existence of custom masks
switch tmasktype
    case 'none'
    otherwise
        [tmasksubjects tmaskfiles]=textread(tmasktype,'%s%s');
        if ~isequal(tmasksubjects,subjects)
            error('masklist subjects do not match cohortfile subjects');
        end
        for i=1:numel(tmaskfiles)
            fprintf('\t%d\t%s\n',i,subjects{i,1});
            if ~exist(tmaskfiles{i,1})
                error('\t%s is not found\n',tmaskfiles{i,1});
            end
        end
end

switch hems
    case 'LEFT'
        h = 1;
    case 'RIGHT'
        h = 2;
    case 'BOTH'
        h = [1:2];
end

% Make output folder
system(['mkdir ' outputdir])

for hem = h
    
    if numel(subjects)>1
        avgcrosscorr = zeros(32492,65549);
        %avgcrosscorr_surf = zeros(32492,32492);
    end
    maskout = zeros(1,65549);
    
    for s = 1:length(subjects)
        disp(['Processing subject #' num2str(s) ': ' subjects{s}])
        subject = strcat(subjects{s});
        funcpath = strcat(funcpaths{s});
        funcvol = strcat(funcvols{s});
        surfdir = strcat(surfdirs{s});
        
        if ~exist([outputdir '/' subject '_BOLD_' HEMS{hem} '_smooth' num2str(smoothnum) '_32k_fsLR.func.gii'])
            
            % Move funcvol to outputdir and convert to nifti
            system(['cp ' funcpath '/' funcvol '.4dfp.* ' outputdir]);
            cd(outputdir)
            system(['nifti_4dfp -n ' outputdir '/' funcvol '.4dfp.img ' outputdir '/' funcvol '.nii']);
            
            % Sample timecourse to surface
            disp('Projecting timecourses to surface')
            BOLDname = [subject '_BOLD_' HEMS{hem}];
            
            midsurf = [surfdir '/Native/' subject '.' HEMS{hem} '.midthickness.native.surf.gii'];
            whitesurf = [surfdir '/Native/' subject '.' HEMS{hem} '.white.native.surf.gii'];
            pialsurf = [surfdir '/Native/' subject '.' HEMS{hem} '.pial.native.surf.gii'];
            system([workbenchdir '/wb_command -volume-to-surface-mapping ' outputdir '/' funcvol '.nii ' midsurf ' ' BOLDname '.func.gii -ribbon-constrained ' whitesurf ' ' pialsurf ' -voxel-subdiv 5']);
            
            %Smooth BOLD data on surface
            switch smooth
                case 'no'
                case 'yes'
                    disp('Smoothing data on surface')
                    system([workbenchdir '/wb_command -metric-smoothing ' midsurf ' ' BOLDname '.func.gii ' num2str(smoothnum) ' ' BOLDname '_smooth' num2str(smoothnum) '.func.gii']);
                    system(['rm ' BOLDname '.func.gii']);
                    BOLDname = [BOLDname '_smooth' num2str(smoothnum)];
            end
            
            % Deform from native to 32K fs_LR surface
            disp('Deform timecourse to 32k fs_LR')
            cd([surfdir '/fsaverage_LR32k/'])
            system(['caret_command64 -deformation-map-apply native232k_fs_LR.' HEMS{hem} '.deform_map METRIC_AVERAGE_TILE ' outputdir '/' BOLDname '.func.gii ' outputdir '/' BOLDname '_32k_fsLR.func.gii']);
        
        else
            BOLDname = [subject '_BOLD_' HEMS{hem} '_smooth' num2str(smoothnum)];
        end
        
        % Convert surface timecourses to be read my matlab
        cd(outputdir)
        system(['rm ' BOLDname '.func.gii']);
        BOLDname = [BOLDname '_32k_fsLR'];
        system(['caret_command64 -file-convert -format-convert ASCII ' BOLDname '.func.gii']);
        system(['rm ' BOLDname '_noHEAD.func.gii']);
        system(['awk ''NF > 25'' ' BOLDname '.func.gii > ' BOLDname '_noHEAD.func.gii']);
        
        % Load surface and volume data
        surf_BOLD = load([BOLDname '_noHEAD.func.gii']);
        surf_BOLD(:,1) = [];
        
        mask = read_4dfpimg(mask4dfp);
        BOLD = read_4dfpimg([funcpath '/' funcvol '.4dfp.img']);
        vol_BOLD = BOLD(logical(mask),:)';        
        
        % Tmask data
        switch tmasktype
            case 'none'
            otherwise
                tmask = load(tmaskfiles{s});
                surf_BOLD = surf_BOLD(:,logical(tmask));
                vol_BOLD = vol_BOLD(logical(tmask),:);
        end
        
        % Calculate correlation between surface and volume data
        fprintf('Calculating correlation between surface nodes and volume...')
        crosscorr = FisherTransform(paircorr_mod(single(surf_BOLD)',single(vol_BOLD)));
        
        %crosscorr_surf = FisherTransform(paircorr_mod(single(surf_BOLD)'));
        
        % Keep running correlation map average
        if numel(subjects)>1
            avgcrosscorr = avgcrosscorr + crosscorr;
            %avgcrosscorr_surf = avgcrosscorr_surf + crosscorr_surf;
        end
        
        % Keep track of voxels without data by subject
        maskout = maskout + isnan(crosscorr(1,:));
        
        system(['rm ' BOLDname '_noHEAD.func.gii']);
        system(['rm ' funcvol '.*']);
        disp('done.')
     end
    
    if numel(subjects)>1
        clear crosscorr crosscorr_surf
        avgcrosscorr = avgcrosscorr./(length(subjects));
        %avgcrosscorr_surf = avgcrosscorr_surf./(length(subjects));
        %save([filestem 'avgcrosscorr_surf_' HEMS{hem} '.mat'],'avgcrosscorr_surf','-v7.3')
    else
        avgcrosscorr = crosscorr;
        clear crosscorr
    end
    
%load avgcrosscorr.mat

    % Remove voxels from crosscorr that have no BOLD data but are in glm mask
    nanmat = isnan(avgcrosscorr);
    nancolsum = sum(nanmat,2)==length(avgcrosscorr(1,:));
    nanmat(logical(nancolsum),:) = [];
    nanrowsum = sum(nanmat,1)>0;
    avgcrosscorr(:,logical(nanrowsum)) = [];
    
    % Create mask based on nodes that don't get projected to
    medialind = find(isnan(avgcrosscorr(:,1)));
    medialmask = ones(size(avgcrosscorr,1),1);
    medialmask(medialind) = 0;
    save(gifti(single(medialmask)),'medialmask.func.gii')
    
    %Load mask
    maskdata = gifti(maskfile);
    maskdata = maskdata.cdata;
    maskedoutind = find(maskdata==0);
    
    % Calculate correlation of correlation maps
    fprintf('Calculating correlation of correlation maps...')
    avgcorrofcorr = paircorr_mod(single(avgcrosscorr)');
    disp('done.')
    avgcorrofcorr(isnan(avgcorrofcorr)) = 0;
    allindtoremove = union(medialind, maskedoutind);
    avgcorrofcorr(allindtoremove,:) = [];
    
    % Save metrics
    cd(outputdir)
    fprintf('Saving corr of corr maps...')
    save(gifti(avgcorrofcorr(1:floor(size(avgcorrofcorr,1)/2),:)),['avg_corrofcorr_' HEMS{hem} '_piece1.func.gii'],'ExternalFileBinary');
    save(gifti(avgcorrofcorr(floor(size(avgcorrofcorr,1)/2)+1:end,:)),['avg_corrofcorr_' HEMS{hem} '_piece2.func.gii'],'ExternalFileBinary');
    disp('done.')
    
    % Calculate gradient
    atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser';
    specfile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.32k_fs_LR.c5.spec'];
    midsurf_32k = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.midthickness.32k_fs_LR.surf.gii'];
    coordfile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.midthickness.32k_fs_LR.coord.gii'];
    topofile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.32k_fs_LR.topo.gii'];
    
    fprintf('Calculating Gradients...')
    filestem = ['avgcorrofcorr_smooth' num2str(smoothnum) '_allgrad_' HEMS{hem}];
    system(['caret_command64 -metric-gradient-all ' coordfile ' ' topofile ' avg_corrofcorr_' HEMS{hem} '_piece1.func.gii ' filestem '_piece1.func.gii FALSE ' num2str(smoothnum) ' TRUE']);
    system(['caret_command64 -metric-gradient-all ' coordfile ' ' topofile ' avg_corrofcorr_' HEMS{hem} '_piece2.func.gii ' filestem '_piece2.func.gii FALSE ' num2str(smoothnum) ' TRUE']);
    
    system(['rm avg_corrofcorr_' HEMS{hem} '_piece*'])
    
    % Reformatting files to load into Matlab
    fprintf('Reformatting gifti files to load into matlab')
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece1.func.gii'])
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece2.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece1_noHEAD.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece2_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece1.func.gii > ' filestem '_piece1_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece2.func.gii > ' filestem '_piece2_noHEAD.func.gii'])
    grad_metrics_piece1 = load([outputdir '/' filestem '_piece1_noHEAD.func.gii']);
    grad_metrics_piece1(:,1) = [];
    grad_metrics_piece2 = load([outputdir '/' filestem '_piece2_noHEAD.func.gii']);
    grad_metrics_piece2(:,1) = [];
    grad_metrics = [grad_metrics_piece1 grad_metrics_piece2];
    
    % Calculate and save average gradient map
    avg_metric = mean(grad_metrics,2);
    save(gifti(single(avg_metric)),[filestem '_avg.func.gii']);
    
    % Calculate edge maps
    switch edges
        case 'no'
        case 'yes'
            surface_edges_all_test_faster(grad_metrics,specfile,outputdir,[filestem '_edge_avg'],1);
    end
       
    % Extra smoothing step...
    fprintf('Smoothing gradients before calculating edges...')
    system(['caret_command64 -metric-smoothing ' coordfile ' ' topofile ' ' filestem '_piece1.func.gii ' filestem '_smooth' num2str(smoothnum) '_piece1.func.gii GEOGAUSS 1 1 -geo-gauss ' num2str(smoothnum)])
    system(['caret_command64 -metric-smoothing ' coordfile ' ' topofile ' ' filestem '_piece2.func.gii ' filestem '_smooth' num2str(smoothnum) '_piece2.func.gii GEOGAUSS 1 1 -geo-gauss ' num2str(smoothnum)])
    
    % Remove intermediate file
    system(['rm ' filestem '_piece*']);
    system(['rm ' filestem '_piece*']);
    
    % Reformatting files to load into Matlab
    filestem = [filestem '_smooth' num2str(smoothnum)];
    fprintf('Reformatting gifti files to load into matlab')
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece1.func.gii'])
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece2.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece1_noHEAD.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece2_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece1.func.gii > ' filestem '_piece1_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece2.func.gii > ' filestem '_piece2_noHEAD.func.gii'])
    grad_metrics_piece1 = load([outputdir '/' filestem '_piece1_noHEAD.func.gii']);
    grad_metrics_piece1(:,1) = [];
    grad_metrics_piece2 = load([outputdir '/' filestem '_piece2_noHEAD.func.gii']);
    grad_metrics_piece2(:,1) = [];
    grad_metrics = [grad_metrics_piece1 grad_metrics_piece2];
    
    % Clean up files
    system(['rm ' filestem '_piece*']);
    system(['rm ' filestem '_piece*']);
    
    % Calculate and save average gradient map
    avg_metric = mean(grad_metrics,2);
    save(gifti(avg_metric),[filestem '_avg.func.gii']);   
   
    % Calculate edge maps
    switch edges
        case 'no'
        case 'yes'
            surface_edges_all_test_faster(grad_metrics,specfile,outputdir,[filestem '_edge_avg'],1);
    end
    

end