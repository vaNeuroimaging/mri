%function  surface_parcellation(cohortfile,outputdir,tmasktype,smooth,hems,edges)
%Generate gradient-based parcellation on surface registered subject data
% This script requires a parcellation cohortfile file. The cohortfile includes
% a list of the subject names, the functional volume to be parcellated including
% its path, and the directory where the subject's surface is (as generated by 
% Freesurfer and registered to fs_LR space), formatted as:
% 
% subjectname funcpath/funcvol surfdir
% 
% e.g. 
%
% vc33416 /data/cn4/laumannt/vc33416_rest1.4dfp.img /data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/vc33416/7112b_fs_LR
%
% With 'tmasktype', users can enter a tmasklist.txt as created by
% fcimage_analysis to mask out timepoints in their data. Enter 'none' if no
% temporal mask is needed.
% If 'smooth' is set to  'yes' data will be smoothed along the cortical
% surface after surface projection. Enter 'no' if no surface smoothing is
% desired.
% With 'hems', users can specify that either the 'LEFT', 'RIGHT', or 'BOTH'
% hemispheres be parcellated.
% If 'edges' is set to 'yes' a final non-maxima suppression step will be
% applied to the gradient maps and an edge frequency map will be output in
% addition to an average gradient map. Enter 'no' if edge detection is not
% desired.
% This version of surface parcellation will always average correlation data
% from all subjects, generating a single gradient and/or edge map for the
% group.
%Run on tsunami
%matlab12
%addpath /data/cn4/laumannt/assignment_problem_v2/Scripts/
%addpath /data/cn4/laumannt/surface_gradient_code/
%outputdir - full path

% TOL 01/25/13

outputdir = '/data/cn4/evan/Task_parcellation/HCPSubjects/Parcellation_Group36_46beta/';
voldata = [outputdir 'Meansub_allbetas.nii'];
surfdata = [outputdir 'Meansub_allbetas_L.func.gii'];
smooth = 'no';
hems = 'LEFT';
edges = 'yes';
medialmask = '/data/cn4/evan/RestingState/FC_Mapping_120/medialmask.func.gii';
medialmaskdata = gifti(medialmask);
medialind = find(medialmaskdata.cdata==0);

divisions = 12;

system(['nifti_4dfp -4 ' voldata ' ' voldata(1:end-4)])

smoothnum = 2.55;
%mask4dfp='/data/cn4/laumannt/Standard/glm_atlas_mask_222.4dfp.img';
workbenchdir = '/data/cn4/laumannt/workbench/bin_linux64/';
HEMS = {'L';'R'};
hemname = {'LEFT';'RIGHT'};

hems = 'LEFT';

% [ign subnum] = system(['cat ' cohortfile ' | wc -l']);
% subnum = str2num(subnum);
% 
% % Read in subject names, functional volume locations, and surface directory
% for s = 1:subnum
% [ign subjects{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $1}'' ' cohortfile]);
% [ign funcpaths{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $2}'' ' cohortfile ' | awk -F ''/'' ''sub(FS $NF,x)''']);
% [ign funcvols{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $2}'' ' cohortfile ' | awk -F ''/'' ''{print $NF}'' | awk -F ''.'' ''{print $1}''']);
% [ign surfdirs{s,1}] = system(['awk -F '' '' ''NR==' num2str(s) '{printf $3}'' ' cohortfile]);
% end

% % Check masktype and the existence of custom masks
% switch tmasktype
%     case 'none'
%     otherwise
%         [tmasksubjects tmaskfiles]=textread(tmasktype,'%s%s');
%         if ~isequal(tmasksubjects,subjects)
%             error('masklist subjects do not match cohortfile subjects');
%         end
%         for i=1:numel(tmaskfiles)
%             fprintf('\t%d\t%s\n',i,subjects{i,1});
%             if ~exist(tmaskfiles{i,1})
%                 error('\t%s is not found\n',tmaskfiles{i,1});
%             end
%         end
% end

switch hems
    case 'LEFT'
        h = 1;
    case 'RIGHT'
        h = 2;
    case 'BOTH'
        h = [1:2];
end

% Make output folder
system(['mkdir ' outputdir])

for hem = h
    
%    if numel(subjects)>1
%        avgcrosscorr = zeros(32492,65549);
%        %avgcrosscorr_surf = zeros(32492,32492);
%    end
    maskout = zeros(1,65549);
    
%     for s = 1:length(subjects)
%         disp(['Processing subject #' num2str(s) ': ' subjects{s}])
%         subject = strcat(subjects{s});
%         funcpath = strcat(funcpaths{s});
%         funcvol = strcat(funcvols{s});
%         surfdir = strcat(surfdirs{s});
        
        % Move funcvol to outputdir and convert to nifti
        %system(['cp ' funcvol '.nii ' outputdir])
        cd(outputdir)
        %system(['nifti_4dfp -n ' outputdir '/' funcvol '.4dfp.img ' outputdir '/' funcvol '.nii']);
        
        % Sample timecourse to surface
%         disp('Projecting timecourses to surface')
%         BOLDname = [subject '_BOLD_' HEMS{hem}];
%             
%         midsurf = [surfdir '/Native/' subject '.' HEMS{hem} '.midthickness.native.surf.gii'];
%         whitesurf = [surfdir '/Native/' subject '.' HEMS{hem} '.white.native.surf.gii'];
%         pialsurf = [surfdir '/Native/' subject '.' HEMS{hem} '.pial.native.surf.gii'];
%         system([workbenchdir '/wb_command -volume-to-surface-mapping ' outputdir '/' funcvol '.nii ' midsurf ' ' BOLDname '.func.gii -ribbon-constrained ' whitesurf ' ' pialsurf ' -voxel-subdiv 5']);
        
        %map_vol_to_surface(voldata,'L')
        
        %BOLDname = [voldata(1:end-4) '_L'];
        
        %midsurf = '/data/cn4/evan/fsaverage_LR32k/Conte69.L.midthickness.32k_fs_LR.surf.gii';

        % Smooth BOLD data on surface
%         switch smooth
%             case 'no'
%             case 'yes'
%                 disp('Smoothing data on surface')
%                 system([workbenchdir '/wb_command -metric-smoothing ' midsurf ' ' BOLDname '.func.gii ' num2str(smoothnum) ' ' BOLDname '_smooth' num2str(smoothnum) '.func.gii'])
%                 system(['rm ' BOLDname '.func.gii'])
%                 BOLDname = [BOLDname '_smooth' num2str(smoothnum)];
%         end
        
%         % Deform from native to 32K fs_LR surface
%         disp('Deform timecourse to 32k fs_LR')
%         cd([surfdir '/fsaverage_LR32k/'])
%         system(['caret_command64 -deformation-map-apply native232k_fs_LR.' HEMS{hem} '.deform_map METRIC_AVERAGE_TILE ' outputdir '/' BOLDname '.func.gii ' outputdir '/' BOLDname '_32k_fsLR.func.gii']);
%         
        % Convert surface timecourses to be read my matlab
        cd(outputdir)
        %system(['rm ' BOLDname '.func.gii'])
        %BOLDname = [BOLDname '_32k_fsLR'];
%         system(['caret_command64 -file-convert -format-convert ASCII ' BOLDname '.func.gii'])
%         system(['rm ' BOLDname '_noHEAD.func.gii']);
%         system(['awk ''NF > 25'' ' BOLDname '.func.gii > ' BOLDname '_noHEAD.func.gii'])
        
        % Load surface and volume data
%         surf_BOLD = load([BOLDname '_noHEAD.func.gii']);
%         surf_BOLD(:,1) = [];

        surf_BOLD = gifti_evan(surfdata);
        surf_BOLD = surf_BOLD.data{1}.data;
        
        %mask = read_4dfpimg(mask4dfp);
        BOLD = read_4dfpimg_HCP([voldata(1:end-4) '.4dfp.img']);
        
        mask = ~(sum(BOLD==0,2)>0);
        
        vol_BOLD = BOLD(logical(mask),:)';        
        
%         % Tmask data
%         switch tmasktype
%             case 'none'
%             otherwise
%                 tmask = load(tmaskfiles{s});
%                 surf_BOLD = surf_BOLD(:,logical(tmask));
%                 vol_BOLD = vol_BOLD(logical(tmask),:);
%         end
        
        % Calculate correlation between surface and volume data
        nodesperdivision = ceil(size(surf_BOLD,1) / divisions);
        
        disp('Calculating correlation between surface nodes and volume')
        for divisionnum = 1:divisions
            
            if divisionnum==divisions
                indices{divisionnum} = nodesperdivision*(divisionnum-1)+1 : size(surf_BOLD,1);
            else
                indices{divisionnum} = nodesperdivision*(divisionnum-1)+1 : nodesperdivision*divisionnum;
            end
            
            crosscorr = FisherTransform(paircorr_mod(single(surf_BOLD(indices{divisionnum},:))',single(vol_BOLD)));
            
            % Remove voxels from crosscorr that have no BOLD data but are in glm mask
            nanmat = isnan(crosscorr);
            nancolsum = sum(nanmat,2)==size(crosscorr,2);
            nanmat(logical(nancolsum),:) = [];
            nanrowsum = sum(nanmat,1)>0;
            %nanrowsum = repmat(nanrowsum,1,numwindows);
            crosscorr(:,logical(nanrowsum)) = [];
            
            save([outputdir '/CrosscorrDivision' num2str(divisionnum) '.mat'],'crosscorr','-v7.3')
            
            clear crosscorr
            
        end
        
        
        %evalc(['!rm ' BOLDname '_noHEAD.func.gii']);
        %evalc(['!rm ' funcvol '.*']);
        disp('done.')
        
        
        
        %         avgcrosscorr = crosscorr;
        %         clear crosscorr
        
        
        
        
        % Create mask based on nodes that don't get projected to
        %medialind = isnan(medialmaskcheckmatrix);
        %medialmask = ones(length(medialmaskcheckmatrix),1);
        %medialmask(medialind) = 0;
        %save(gifti(single(medialmask)),'medialmask.func.gii')
        
        %for piecenum = 1:(numwindows*2)
        
        % Calculate correlation of correlation maps
        fprintf('Calculating correlation of correlation maps...')
        disp(' ')
        avgcorrofcorr = zeros(size(surf_BOLD,1),'single');
        
        
        
        divisionnum = 0;
        
        for i = 1:divisions
            
            load([outputdir '/CrosscorrDivision' num2str(i) '.mat']);
            crosscorri = crosscorr;
            
            for j = 1:divisions
                
                if i >= j
                    
                    load([outputdir '/CrosscorrDivision' num2str(j) '.mat']);
                    crosscorrj = crosscorr;
                    
                    divisionnum = divisionnum+1;
                    
                    string{divisionnum} = ['Calculating correlations for division number ' num2str(divisionnum) ' of ' num2str((divisions^2 + divisions)/2)];
                    if divisionnum==1; fprintf('%s',string{divisionnum}); else fprintf([repmat('\b',1,length(string{divisionnum-1})) '%s'],string{divisionnum}); end
                    
                    avgcorrofcorr(indices{i},indices{j}) = paircorr_mod(crosscorri',crosscorrj');
                    
                end
                
            end
        end
        disp(' ')
        
        clear crosscorr crosscorri crosscorrj
        
        avgcorrofcorr = tril(avgcorrofcorr,-1) + tril(avgcorrofcorr)';
        
        system(['rm ' outputdir '/CrosscorrDivision*.mat']);
        
        
%         
%         
%         %crosscorr = FisherTransform(paircorr_mod(single(surf_BOLD)',single(vol_BOLD)));
%         
%         %crosscorr_surf = FisherTransform(paircorr_mod(single(surf_BOLD)'));
%         
% %         % Keep running correlation map average
% %         if numel(subjects)>1
% %             avgcrosscorr = avgcrosscorr + crosscorr;
% %             %avgcrosscorr_surf = avgcrosscorr_surf + crosscorr_surf;
% %         end
%         
%         % Keep track of voxels without data by subject
%         maskout = maskout + isnan(crosscorr(1,:));
%         
%         system(['rm ' BOLDname '_noHEAD.func.gii'])
%         system(['rm ' funcvol '.*'])
%         disp('done.')
%     %end
%     
% %     if numel(subjects)>1
% %         clear crosscorr crosscorr_surf
% %         avgcrosscorr = avgcrosscorr./(length(subjects));
% %         %avgcrosscorr_surf = avgcrosscorr_surf./(length(subjects));
% %         %save([filestem 'avgcrosscorr_surf_' HEMS{hem} '.mat'],'avgcrosscorr_surf','-v7.3')
% %     else
%         avgcrosscorr = crosscorr;
%         clear crosscorr
% %    end
%     
%     % Remove voxels from crosscorr that have no BOLD data but are in glm mask
%     nanmat = isnan(avgcrosscorr);
%     nancolsum = sum(nanmat,2)==length(avgcrosscorr(1,:));
%     nanmat(logical(nancolsum),:) = [];
%     nanrowsum = sum(nanmat,1)>0;
%     avgcrosscorr(:,logical(nanrowsum)) = [];
%     
%     % Create mask based on nodes that don't get projected to
%     medialind = isnan(avgcrosscorr(:,1));
%     medialmask = ones(size(avgcrosscorr,1),1);
%     medialmask(medialind) = 0;
%     save(gifti(single(medialmask)),'medialmask.func.gii')
%     
%     % Calculate correlation of correlation maps
%     fprintf('Calculating correlation of correlation maps...')
%     avgcorrofcorr = paircorr_mod(single(avgcrosscorr)');
    disp('done.')
    avgcorrofcorr(isnan(avgcorrofcorr)) = 0;
    avgcorrofcorr(medialind,:) = [];
    
    % Save metrics
    cd(outputdir)
    fprintf('Saving corr of corr maps...')
    save(gifti(avgcorrofcorr(1:floor(size(avgcorrofcorr,1)/2),:)),['avg_corrofcorr_' HEMS{hem} '_piece1.func.gii'],'ExternalFileBinary');
    save(gifti(avgcorrofcorr(floor(size(avgcorrofcorr,1)/2)+1:end,:)),['avg_corrofcorr_' HEMS{hem} '_piece2.func.gii'],'ExternalFileBinary');
    disp('done.')
    
    % Calculate gradient
    atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser';
    specfile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.32k_fs_LR.c5.spec'];
    midsurf_32k = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.midthickness.32k_fs_LR.surf.gii'];
    coordfile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.midthickness.32k_fs_LR.coord.gii'];
    topofile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.32k_fs_LR.topo.gii'];
    
    fprintf('Calculating Gradients...')
    filestem = ['avgcorrofcorr_smooth' num2str(smoothnum) '_allgrad_' HEMS{hem}];
    system(['caret_command64 -metric-gradient-all ' coordfile ' ' topofile ' avg_corrofcorr_' HEMS{hem} '_piece1.func.gii ' filestem '_piece1.func.gii FALSE ' num2str(smoothnum) ' TRUE']);
    system(['caret_command64 -metric-gradient-all ' coordfile ' ' topofile ' avg_corrofcorr_' HEMS{hem} '_piece2.func.gii ' filestem '_piece2.func.gii FALSE ' num2str(smoothnum) ' TRUE']);
    
    system(['rm avg_corrofcorr_' HEMS{hem} '_piece*'])
    
    % Reformatting files to load into Matlab
    fprintf('Reformatting gifti files to load into matlab')
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece1.func.gii'])
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece2.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece1_noHEAD.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece2_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece1.func.gii > ' filestem '_piece1_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece2.func.gii > ' filestem '_piece2_noHEAD.func.gii'])
    grad_metrics_piece1 = load([outputdir '/' filestem '_piece1_noHEAD.func.gii']);
    grad_metrics_piece1(:,1) = [];
    grad_metrics_piece2 = load([outputdir '/' filestem '_piece2_noHEAD.func.gii']);
    grad_metrics_piece2(:,1) = [];
    grad_metrics = [grad_metrics_piece1 grad_metrics_piece2];
    
    % Calculate and save average gradient map
    avg_metric = mean(grad_metrics,2);
    save(gifti(single(avg_metric)),[filestem '_avg.func.gii']);
    
    % Calculate edge maps
    switch edges
        case 'no'
        case 'yes'
            surface_edges_all_test_faster(grad_metrics,specfile,outputdir,[filestem '_edge_avg'],1);
    end
       
    % Extra smoothing step...
    fprintf('Smoothing gradients before calculating edges...')
    system(['caret_command64 -metric-smoothing ' coordfile ' ' topofile ' ' filestem '_piece1.func.gii ' filestem '_smooth' num2str(smoothnum) '_piece1.func.gii GEOGAUSS 1 1 -geo-gauss ' num2str(smoothnum)])
    system(['caret_command64 -metric-smoothing ' coordfile ' ' topofile ' ' filestem '_piece2.func.gii ' filestem '_smooth' num2str(smoothnum) '_piece2.func.gii GEOGAUSS 1 1 -geo-gauss ' num2str(smoothnum)])
    
    % Remove intermediate file
    system(['rm ' filestem '_piece*']);
    system(['rm ' filestem '_piece*']);
    
    % Reformatting files to load into Matlab
    filestem = [filestem '_smooth' num2str(smoothnum)];
    fprintf('Reformatting gifti files to load into matlab')
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece1.func.gii'])
    system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' filestem '_piece2.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece1_noHEAD.func.gii'])
    system(['rm ' outputdir '/' filestem '_piece2_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece1.func.gii > ' filestem '_piece1_noHEAD.func.gii'])
    system(['awk ''NF > 25'' ' outputdir '/' filestem '_piece2.func.gii > ' filestem '_piece2_noHEAD.func.gii'])
    grad_metrics_piece1 = load([outputdir '/' filestem '_piece1_noHEAD.func.gii']);
    grad_metrics_piece1(:,1) = [];
    grad_metrics_piece2 = load([outputdir '/' filestem '_piece2_noHEAD.func.gii']);
    grad_metrics_piece2(:,1) = [];
    grad_metrics = [grad_metrics_piece1 grad_metrics_piece2];
    
    % Clean up files
    system(['rm ' filestem '_piece*']);
    system(['rm ' filestem '_piece*']);
    
    % Calculate and save average gradient map
    avg_metric = mean(grad_metrics,2);
    save(gifti(avg_metric),[filestem '_avg.func.gii']);   
   
    % Calculate edge maps
    switch edges
        case 'no'
        case 'yes'
            surface_edges_all_test_faster(grad_metrics,specfile,outputdir,[filestem '_edge_avg'],1);
    end
    

end