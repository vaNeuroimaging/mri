function  surface_parcellation_subsurf_nosmooth_test_vecs(cohortfile,outputdir,tmasktype,hems,edges)
% cohortfile = '/data/hcp-zfs/home/laumannt/120_parcellation/gradients_cifti_smallwall_subsurf_nosmooth_vecs/120/cohortfile.txt';
% tmasktype = '/data/hcp-zfs/home/laumannt/120_parcellation/gradients_cifti_smallwall_subsurf_nosmooth_vecs/120/tmaskfile.txt';
% outputdir = '/data/cn4/evan/Temp/surface_parcellation_vecs/';
% hems = 'LEFT';
% edges = 'yes';

%Generate gradient-based parcellation on surface registered subject data
% This script requires a parcellation cohortfile file. The cohortfile includes
% a list of the subject names, the functional volume to be parcellated including
% its path, and the directory where the subject's surface is (as generated by 
% Freesurfer and registered to fs_LR space), formatted as:
% 
% subjectname funcpath/funcvol surfdir
% 
% e.g. 
%
% vc33416 /data/cn4/laumannt/vc33416_rest1.4dfp.img /data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/vc33416/7112b_fs_LR
%
% With 'tmasktype', users can enter a tmasklist.txt as created by
% fcimage_analysis to mask out timepoints in their data. Enter 'none' if no
% temporal mask is needed.
% If 'smooth' is set to  'yes' data will be smoothed along the cortical
% surface after surface projection. Enter 'no' if no surface smoothing is
% desired.
% With 'hems', users can specify that either the 'LEFT', 'RIGHT', or 'BOTH'
% hemispheres be parcellated.
% If 'edges' is set to 'yes' a final non-maxima suppression step will be
% applied to the gradient maps and an edge frequency map will be output in
% addition to an average gradient map. Enter 'no' if edge detection is not
% desired.
% This version of surface parcellation will always average correlation data
% from all subjects, generating a single gradient and/or edge map for the
% group.
% TOL 01/25/13

smoothnum = 2.55;
mask4dfp='/data/cn4/laumannt/Standard/glm_atlas_mask_333.4dfp.img';
%workbenchdir = 'env nice -n 4 /data/cn4/laumannt/workbench/bin_linux64/';
workbenchdir = 'nice /data/cn4/laumannt/workbench/bin_linux64/';
%roidir = '/data/cn4/laumannt/subcortical_mask';
%roidir = '/data/hcp-zfs/home/laumannt/120_parcellation';
roidir = '/data/cn4/laumannt/subcortical_mask';
HEMS = {'L';'R'};
hemname = {'LEFT';'RIGHT'};
hemname_low = {'left';'right'};

numpieces = 10;

% Read in subject names, functional volume locations, and surface directory
[subjects cifti_files surfdirs] = textread(cohortfile,'%s%s%s');

% Check masktype and the existence of custom masks
switch tmasktype
    case 'none'
    otherwise
        [tmasksubjects tmaskfiles]=textread(tmasktype,'%s%s');
        if ~isequal(tmasksubjects,subjects)
            error('masklist subjects do not match cohortfile subjects');
        end
        for i=1:numel(tmaskfiles)
            fprintf('\t%d\t%s\n',i,subjects{i,1});
            if ~exist(tmaskfiles{i,1})
                error('\t%s is not found\n',tmaskfiles{i,1});
            end
        end
end


switch hems
    case 'LEFT'
        h = 1;
        % Load medial wall mask
        medial_wall_L = gifti('/data/hcp-zfs/home/laumannt/120_parcellation/medial_exclude_L.func.gii');
        medial_wall_L = medial_wall_L.cdata;
        cort_L_num = nnz(medial_wall_L==0);
    case 'RIGHT'
        h = 2;
        % Load medial wall mask
        medial_wall_R = gifti('/data/hcp-zfs/home/laumannt/120_parcellation/medial_exclude_R.func.gii');
        medial_wall_R = medial_wall_R.cdata;
        medial_wall_L = gifti('/data/hcp-zfs/home/laumannt/120_parcellation/medial_exclude_L.func.gii');
        medial_wall_L = medial_wall_L.cdata;
        cort_L_num = nnz(medial_wall_L==0);
        cort_R_num = nnz(medial_wall_R==0);
    case 'BOTH'
        h = [1:2];
        % Load medial wall mask
        medial_wall_L = gifti('/data/hcp-zfs/home/laumannt/120_parcellation/medial_exclude_L.func.gii');
        medial_wall_L = medial_wall_L.cdata;
        medial_wall_R = gifti('/data/hcp-zfs/home/laumannt/120_parcellation/medial_exclude_R.func.gii');
        medial_wall_R = medial_wall_R.cdata;
        cort_L_num = nnz(medial_wall_L==0);
        cort_R_num = nnz(medial_wall_R==0);
end

% Make output folder
system(['mkdir ' outputdir])


piecesize = floor(32000 / numpieces);

cd(outputdir)
for hem = h
   
    if hem == 1
        %cort_ind = 16491;
        cort_ind = 1:cort_L_num;
        numinds = cort_L_num;
        %pieces = {1:3000;3001:6000;6001:9000;9001:12000;12001:15000;15001:18000;18001:21000;21001:24000;24001:27000;27001:cort_L_num};
    elseif hem == 2
        cort_ind = (cort_L_num+1):(cort_L_num+cort_R_num);
        numinds = cort_R_num;
        %pieces = {1:3000;3001:6000;6001:9000;9001:12000;12001:15000;15001:18000;18001:21000;21001:24000;24001:27000;27001:cort_R_num};
    end
    
    for i = 1:(numpieces-1)
       pieces{i,1} = [((i-1)*piecesize + 1) : (i*piecesize)];
    end
    pieces{numpieces,1} = [((numpieces-1)*piecesize + 1) : numinds];
            
            
    % Load medial wall mask
    medial_wall = gifti(['/data/hcp-zfs/home/laumannt/120_parcellation/medial_exclude_' HEMS{hem} '.func.gii']);
    medial_wall = medial_wall.cdata;
    fullgrads = zeros(32492,nnz(medial_wall==0),3);
    
  %  ind_num = 16941;
  gradsname = ['corrofcorr_grad_' HEMS{hem}];
    tic
%     for s = 1:length(subjects)
%         
%         subject = subjects{s};
%         cifti_file = cifti_files{s}(1:(end-13));
%         surfdir = surfdirs{s};
%         tmask = load(tmaskfiles{s});
%         surfdir = ['/data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/' subject '/7112b_fs_LR/'];
%         midsurf_32k = [surfdir '/fsaverage_LR32k/' subject '.' HEMS{hem} '.midthickness.32k_fs_LR.surf.gii'];
%         disp(['Processing subject #' num2str(s) ': ' subject])
%         
%         % Convert cifti to gifti and load timecourse
%         disp('Calculating correlation maps')
%         evalc(['!' workbenchdir '/wb_command -cifti-convert -to-gifti-ext ' cifti_file '.dtseries.nii ' cifti_file '.func.gii']);
%         
%         cifti_timecourse = gifti([cifti_file '.func.gii']);
%         cifti_timecourse = cifti_timecourse.cdata;
%         
%         % Calculate correlation maps
%         %cifti_corrmap = corrcoef(cifti_timecourse(cort_ind,logical(tmask))');
%         cifti_corrmap = paircorr_mod(cifti_timecourse(cort_ind,logical(tmask))',cifti_timecourse(:,logical(tmask))');
%    %     cifti_corrmaps(:,s) = cifti_corrmap(ind_num,:)';
%         disp('done')
%         toc
%         
%         disp('Removing NaNs')
%         cifti_corrmap(isnan(cifti_corrmap)) = 0;
%         
%         % Calculate corr of corr
%         disp('Calculating corr of corr')
%         
%          corrofcorr = corrcoef(cifti_corrmap');
% 
%     %    corrofcorr = paircorr_mod(cifti_corrmap(ind_num,:)',cifti_corrmap');
%     %    corrofcorrs(:,s) = corrofcorr';
%         disp('done')
%         toc
%         clear cifti_corrmap
%         
%         % Write out cifti file
%         %       templatefile = ['/data/hcp-zfs/home/laumannt/120_parcellation/cifti_temp_' HEMS{hem} '_smallwall.func.gii'];
%         %       cifti_write_wHDR(corrofcorr',templatefile,[subject '_corrofcorr_' HEMS{hem}],'dtseries')
%         
%         for p = 1:length(pieces)
%             % Write out metric file
%             disp(['Piece ' num2str(p) ' of ' num2str(length(pieces))])
%             metric = zeros(32492,length(pieces{p}));
%             metric(~logical(medial_wall),:) = corrofcorr(pieces{p},:)';
%             save(gifti(single(metric)),['corrofcorr_' HEMS{hem} '_temp.func.gii'],'ExternalFileBinary')
%             clear metric
%             
%             % Calculate gradients
%             disp('Calculating gradient')
             
%             atlasroi = ['/data/hcp-zfs/home/laumannt/120_parcellation/' HEMS{hem} '.atlasroi_group_noproj.func.gii'];
%             
%             if s==1
%                 system([workbenchdir '/wb_command -metric-gradient ' midsurf_32k ' ' outputdir '/corrofcorr_' HEMS{hem} '_temp.func.gii ' outputdir '/' gradsname '.func.gii -roi ' atlasroi ' -vectors ' outputdir '/' gradsname '_piece' num2str(p) '_vectors.func.gii']);%' -surface-presmooth 2.55']);
%             else
%                 system([workbenchdir '/wb_command -metric-gradient ' midsurf_32k ' ' outputdir '/corrofcorr_' HEMS{hem} '_temp.func.gii ' outputdir '/' gradsname '.func.gii -roi ' atlasroi ' -vectors ' outputdir '/' gradsname '_vectors_temp.func.gii']);%' -surface-presmooth 2.55']);
%                 system([workbenchdir '/wb_command -metric-math ''a + b'' ' outputdir '/' gradsname '_piece' num2str(p) '_vectors.func.gii -var a ' outputdir '/' gradsname '_piece' num2str(p) '_vectors.func.gii -var b ' outputdir '/' gradsname '_vectors_temp.func.gii'])
%             end
%             toc
%             %       evalc(['!' workbenchdir '/wb_command -cifti-gradient ' outputdir '/' subject '_corrofcorr_' HEMS{hem} '.dtseries.nii COLUMN ' outputdir '/' gradsname '.dtseries.nii -' hemname_low{hem} '-surface ' midsurf_32k ]);%' -surface-presmooth 2.55']);
%             
%             %         % Average gradients
%             %         system([workbenchdir '/wb_command -cifti-reduce ' outputdir '/' gradsname '.dconn.nii MEAN ' outputdir '/' gradsname '_avg.dtseries.nii'])
%             %
%             
%             % Convert gradients and load
%             %      evalc(['!' workbenchdir '/wb_command -cifti-convert -to-gifti-ext ' outputdir '/' gradsname '.dtseries.nii ' outputdir '/' gradsname '.func.gii'])
%             %      grads = gifti([outputdir '/' gradsname '.func.gii']);
%             
% %             system(['caret_command64 -file-convert -format-convert ASCII ' gradsname '_vectors.func.gii'])
% %             system(['awk ''NF > 25'' ' gradsname '_vectors.func.gii > ' gradsname '_vectors_noHEAD.func.gii'])
% %             
% %             temp = load([gradsname '_vectors_noHEAD.func.gii']);
% %             temp(:,1) = [];
% %             for v = 1:length(pieces{p})
% %                 grad_vecs(:,pieces{p}(v),:) = temp(:,v*3-2:v*3);
% %             end
%         end
%         %      allgrads(:,s) = grads.cdata;
%         % Add subject gradients to running average
%         %fullgrads = fullgrads + grad_vecs;
%         clear corrofcorr
%         
%     end
    
    fullgrads = zeros(32492,pieces{end}(end),3);
    for p = 1:length(pieces)
        system(['caret_command64 -file-convert -format-convert ASCII ' outputdir '/' gradsname '_piece' num2str(p) '_vectors.func.gii'])
        system(['awk ''NF > 25'' ' outputdir '/' gradsname '_piece' num2str(p) '_vectors.func.gii > ' outputdir '/temp_vectors_noHEAD.func.gii'])
        temp = load([outputdir '/temp_vectors_noHEAD.func.gii']);
        temp(:,1) = [];
        for v = 1:length(pieces{p})
            fullgrads(:,pieces{p}(v),:) = temp(:,v*3-2:v*3);
        end
        clear temp
    end
    
    % Average gradients across subjects
    fullgrads = fullgrads./length(subjects);
    
    norm_avg_grads = sum(fullgrads.^2 , 3) .^ .5;
        
    
%     for n = 1:size(fullgrads,1)
%         disp(['column #' num2str(n)])
%         for p = 1:size(fullgrads,2)
%             norm_avg_grads(n,p) = norm(squeeze(fullgrads(n,p,:)),2);
%         end
%     end
    clear fullgrads
    % Save out average gradients
    %    templatefile = ['/data/hcp-zfs/home/laumannt/120_parcellation/gradients_cifti_smallwall_wateredge/120/avg_corrofcorr_' HEMS{hem} '.func.gii'];
    
    gradsname = ['norm_avggrad_' HEMS{hem}];
    save(gifti(single(norm_avg_grads)),[gradsname '.func.gii'],'ExternalFileBinary')
    %  cifti_write_wHDR(norm_avg_grads,templatefile,gradsname,'dconn')
    clear norm_avg_grads
    %
    %     % Smooth gradients before edge detection
    atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser'; % Use atlas surface now that data is averaged
    midsurf_32k = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.midthickness.32k_fs_LR.surf.gii'];
    disp('Smoothing gradient')
    smooth = 2.55;
    system([workbenchdir '/wb_command -metric-smoothing ' midsurf_32k ' ' outputdir '/' gradsname '.func.gii ' num2str(smooth) ' ' outputdir '/' gradsname '_smooth' num2str(smooth) '.func.gii']);
    % %
    % Average smooth gradients
    %     system([workbenchdir '/wb_command -cifti-reduce ' outputdir '/' gradsname '_smooth' num2str(smooth) '.dconn.nii MEAN ' outputdir '/' gradsname '_smooth' num2str(smooth) 'avg.dtseries.nii'])
    %
    % Convert gradients and load
    %    evalc(['!' workbenchdir '/wb_command -cifti-convert -to-gifti-ext ' outputdir '/' gradsname '_smooth' num2str(smooth) '.dconn.nii ' outputdir '/' gradsname '_smooth' num2str(smooth) '.func.gii'])
    system(['caret_command64 -file-convert -format-convert ASCII ' gradsname '_smooth' num2str(smooth) '.func.gii'])
    system(['awk ''NF > 25'' ' gradsname '_smooth' num2str(smooth) '.func.gii > ' gradsname '_smooth' num2str(smooth) '_noHEAD.func.gii'])
    fullgrads_smooth = load([outputdir '/' gradsname '_smooth' num2str(smooth) '_noHEAD.func.gii']);
    fullgrads_smooth(:,1) = [];
    
    % Save average gradient
    save(gifti(single(mean(fullgrads_smooth,2))),[outputdir '/' gradsname '_smooth' num2str(smooth) '_avg.func.gii'])
    
    %fullgrads_smooth = zeros(32492,nnz(medial_wall==0));
    %fullgrads_smooth(~logical(medial_wall),:) = grads;
    %     clear grads
    %
    %     % For nonmax edge calculation
    %         atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser';
    %         specfile = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.32k_fs_LR.c5.spec'];
    %
    % Calculate edge maps
    switch edges
        case 'no'
        case 'yes'
            disp('Calculating edges')
            fullgrads_medial = fullgrads_smooth;
            fullgrads_medial(logical(medial_wall),:) = 1000;
            minimametrics = metric_minima_all(fullgrads_medial,3);
            clear fullgrads_medial
            %Original water edge
            labels = watershed_algorithm_all_par(fullgrads_smooth,minimametrics,200,1);
            labels_avg = mean(labels==0,2);
            save(gifti(single(labels_avg)),[outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_avg.func.gii']);
            
            save([outputdir '/labels_' HEMS{hem}],'labels','-v7.3');
            
            % Water edge with below threshold edges removed
            thresh = 0.01;%:.005:.04;
            for t = 1:length(thresh)
                newlabels = watershed_edgeremover(labels,fullgrads_smooth,thresh(t));
                labels_avg = mean(newlabels,2);
                save(gifti(single(labels_avg)),[outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_thresh' num2str(thresh(t)) '_avg.func.gii']);
            end
            
            % Nonmaxima suppression-based edges
            % surface_edges_all_test_faster(fullgrads_smooth,specfile,outputdir,[gradsname '_edge_avg'],1);
    end
    %
    %     % system(['rm ' outputdir '/avg_corrofcorr_' HEMS{hem} '.dconn.nii'])
    %     % system(['rm ' outputdir '/' gradsname '_smooth' num2str(smooth) '.func.*']);
    %     % system(['rm ' outputdir '/' gradsname '.dconn.nii']);
    %     % system(['rm ' outputdir '/' gradsname '_smooth' num2str(smooth) '.dconn.nii'])
    %
end
% %exit