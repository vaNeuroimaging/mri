function  surface_parcellation(cohortfile,tmasklist,hems,outputdir)
%surface_parcellation(cohortfile,tmasklist,hems,[outputdir])
%
%Generate gradient-based parcellation on surface registered subject data
%
% This script requires a 'cohortfile' text file. The cohortfile includes
% a list of the subject names, the full path of the surface-mapped cifti
% functional data to be parcellated, and the directory where the subject's
% surface is (as generated by Freesurfer and registered to fs_LR space),
% formatted as: 
% 
% subjectname cifti surfdir
% 
% e.g. 
% vc33416 /data/cn4/laumannt/vc33416_BOLD_LR_surf_subcort_32k_fsLR_smooth2.55.dtseries.nii /data/cn4/segmentation/freesurfer5_supercomputer/FREESURFER_fs_LR/vc33416/7112b_fs_LR
%
% With 'tmasklist', users should specify a text file including a list of
% subject names and the full path to each subject's tmask file (a binary
% text file of length #timepoints indicating timepoints to include (1) or censor
% (0)). The tmasklist is formatted as:
%
% subjectname tmaskfile
%
% e.g.
% vc33416 /data/cn4/laumannt/vc33416_tmasklist.txt
%
% With 'hems', users can specify that either the 'LEFT', 'RIGHT', or 'BOTH'
% hemispheres be parcellated.
%
% 'outputdir' specifies the folder to write results into. Omit to write
% into the working directory.
%
% This version of surface parcellation will average gradient data across
% subjects to generate a mean gradient and edge map for the group.
% 
%
% TOL 01/25/13, modified by EMG 04/03/15


% PARAMETERS TO SET
smooth = 2.55; % sigma for geodesic smoothing applied to gradient maps
workbenchdir = 'nice /data/cn4/laumannt/workbench_v1/bin_rh_linux64/'; %location of workbench
atlasdir = '/data/cn4/laumannt/standard_mesh_atlases/Conte69_atlas.LR.32k_fs_LR_glasser'; % Location of atlas surface
corticalverts_per_hemisphere = 32492; %number of vertices per hemisphere (use 32492 for 32K_fs_LR standard)
neighborsfile = '/data/cn4/evan/Scripts/parcellation_distribute/node_neighbors.txt'; %location of surface node neighbors file from caret -surface-topology-neighbors

%-----------------------------------------------------------------------


if ~exist('outputdir')
    outputdir = pwd;
end

% Hemisphere names
HEMS = {'L';'R'};
hemname = {'LEFT';'RIGHT'};
hemname_low = {'left';'right'};


% Read in subject names, functional volume locations, and surface directory
[subjects cifti_files surfdirs] = textread(cohortfile,'%s%s%s');

% Read in tmasks
[tmasksubjects tmaskfiles]=textread(tmasklist,'%s%s');
if ~isequal(tmasksubjects,subjects)
    error('tmasklist subjects do not match cohortfile subjects');
end


bufsize=16384;
% Read in node neighbor file
[neighbors(:,1) neighbors(:,2) neighbors(:,3) neighbors(:,4) neighbors(:,5) neighbors(:,6) neighbors(:,7)] = ...
textread([neighborsfile],'%u %u %u %u %u %u %u','delimiter',' ','bufsize',bufsize,'emptyvalue',NaN);
neighbors = neighbors+1;


% Interpret hemispheres to run
switch hems
    case {'LEFT' 'left' 'L' 'l'}
        h = 1;
    case {'RIGHT' 'right' 'R' 'r'}
        h = 2;
    case {'BOTH' 'both' 'B' 'b'}
        h = [1:2];
end

% Make output folder
mkdir(outputdir)
cd(outputdir)

for hem = h
    
    %Name of the altas midthickness surface
    midsurf_32k_atlas = [atlasdir '/fsaverage_LR32k/Conte69.' HEMS{hem} '.midthickness.32k_fs_LR.surf.gii'];

    tic
    for s = 1:length(subjects)
        
        subject = subjects{s};
        surfdir = surfdirs{s};
        cifti_file = cifti_files{s};
        tmask = load(tmaskfiles{s});
        
        %Name of this subject's midthickness surface
        midsurf_32k_sub = [surfdir '/fsaverage_LR32k/' subject '.' HEMS{hem} '.midthickness.32k_fs_LR.surf.gii'];
        
        
        disp(['Processing subject #' num2str(s) ': ' subject])
        
        % Load cifti file
        ciftistruct = ft_read_cifti_mod(cifti_file);
        cifti_timecourse = ciftistruct.data;
        ciftistruct.data = [];
        ciftistruct_1D = ciftistruct;
        
        % Set up some values to be used across subjects
        if s==1
            thishem_inds = (1:corticalverts_per_hemisphere) + (corticalverts_per_hemisphere * (hem-1));
            medial_wall = logical(ciftistruct.brainstructure(thishem_inds)==-1);
            fullgrads = zeros(nnz(ciftistruct.brainstructure==hem));
            cort_ind = (1:nnz(ciftistruct.brainstructure==hem)) + nnz(ciftistruct.brainstructure==(hem-1));
        end
            
        
        % Calculate correlation maps
        disp('Calculating correlation map')
        cifti_corrmap = paircorr_mod(cifti_timecourse(cort_ind,logical(tmask))',cifti_timecourse(:,logical(tmask))');
        
        % Remove NaNs (produced if vertices have no data)
        cifti_corrmap(isnan(cifti_corrmap)) = 0;
        % Apply the Fisher tranformation
        cifti_corrmap = FisherTransform(cifti_corrmap);
        
        
        % Calculate correlation similarity
        disp('Calculating similarity map')
        corrofcorr = corrcoef(cifti_corrmap');
        
        % Apply the Fisher tranformation
        corrofcorr = FisherTransform(corrofcorr);
        
        % Write out corr of corr cifti file for gradient calculation   
        ciftistruct.brainstructure = ciftistruct.brainstructure(thishem_inds);
        ciftistruct.pos = ciftistruct.pos(thishem_inds,:);
        ciftistruct.hdr.dim(6:7) = size(corrofcorr);
        ciftistruct = rmfield(ciftistruct,'transform');
        ciftistruct = rmfield(ciftistruct,'dim');
        ciftistruct = rmfield(ciftistruct,'brainstructurelabel');
        ciftistruct.brainstructurelabel{1} = ['CORTEX_' hemname{hem}];
        ciftistruct.dimord = 'pos_pos';
        ciftistruct.data = corrofcorr;
        clear corrofcorr
        ft_write_cifti_mod(['corrofcorr_' HEMS{hem}],ciftistruct);
        ciftistruct.data = [];
        toc
        
        % Calculate gradients
        disp('Calculating gradient')
        gradsname = ['corrofcorr_allgrad_' HEMS{hem}];
        system([workbenchdir '/wb_command -cifti-gradient ' outputdir '/corrofcorr_' HEMS{hem} '.dconn.nii ROW ' outputdir '/' gradsname '.dconn.nii -' hemname_low{hem} '-surface ' midsurf_32k_sub ]);
        
        % Convert gradients and load
        grads = ft_read_cifti_mod([outputdir '/' gradsname '.dconn.nii']);
        grads = grads.data;
        
        % Add subject gradients to running average
        fullgrads = [fullgrads + grads];
        toc
        clear grads
    end
    
    
    %Average gradients across subjects
    fullgrads = fullgrads./length(subjects);
    
    %Save out average gradients
    ciftistruct.data = fullgrads;
    gradsname = ['avg_corrofcorr_allgrad_' HEMS{hem}];
    ft_write_cifti_mod(gradsname,ciftistruct);
    ciftistruct.data = [];
    clear fullgrads
    
    % Smooth gradients before edge detection
    disp('Smoothing average gradient')
    system([workbenchdir '/wb_command -cifti-smoothing ' outputdir '/' gradsname '.dconn.nii ' num2str(smooth) ' 0 ROW ' outputdir '/' gradsname '_smooth' num2str(smooth) '.dconn.nii -' hemname_low{hem} '-surface ' midsurf_32k_atlas]);

    % Load smoothed gradients
    ciftistruct = ft_read_cifti_mod([outputdir '/' gradsname '_smooth' num2str(smooth) '.dconn.nii']);
    
    % Average smoothed gradients across maps (unused but useful to look at)
    ciftistruct_1D.data = mean(ciftistruct.data,2);
    ft_write_cifti_orig([outputdir '/' gradsname '_smooth' num2str(smooth) 'avg'],ciftistruct_1D);
    
    % Put smoothed gradients into full surface space
    fullgrads_smooth = zeros(32492,nnz(medial_wall==0));
    fullgrads_smooth(~medial_wall,:) = ciftistruct.data;
    ciftistruct.data = [];
    clear grads
    
    
    disp('Calculating edges')
    
    % Get local minima of each smoothed gradient map
    fullgrads_medial = fullgrads_smooth;
    fullgrads_medial(medial_wall,:) = 1000;
    minimametrics = metric_minima_all(fullgrads_medial,3,neighbors);
    clear fullgrads_medial
    
    % Run watershed-by-flooding algorithm on each gradient map to generate edges
    labels = watershed_algorithm_all_par(fullgrads_smooth,minimametrics,200,1,neighbors);
    
    % Average across gradient maps and save
    labels_avg = mean(labels==0,2);
    save(gifti(single(labels_avg)),[outputdir '/' gradsname '_smooth' num2str(smooth) '_wateredge_avg.func.gii']);
    
    % Save watershed edges from all gradient maps
    ciftistruct.data = labels(~medial_wall,:);
    clear labels
    ft_write_cifti_mod([outputdir '/labels_' HEMS{hem}],ciftistruct);
    clear ciftistruct
    
end