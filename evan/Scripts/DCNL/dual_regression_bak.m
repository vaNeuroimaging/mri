%dual_regression.m
%
%Uses the output from a group ICA analysis to determine individual subject versions
%of the identified components within each subject's functional data.
%
%This is performed by regressing each timepoint against the group
%components, and then regressing the individual's whole functional timecourse of
%against the resulting timecourses of beta weights.
%
%Importantly, the ordering of these resulting individual images (the
%con_000# images SPM spits out) are in the same order as the group
%components (so e.g., con_0004 matches thresh_zstat4).
%
%You must have both SPM5 and Marsbar in your path for this script to work
%
%Created by E. Gordon July 09.


%User-specified stuff (more down on line 67)
%--------------------------------------------------------------------------
components_to_use = [1 3 5 6 7 8 10 12 13 15 16 17 19 21 22 23 24 25 27 30];

subjects = {'101','102','113','118','120','122','125','127','132','138','147','150','151','154','156','159','160','161','162','166','172','181','182','187','202','207','211','214','215','221','225','229','232','233','242','250','254','255','272','274'};

%A mask used to restrict analyses to within the brain.  
%This is needed so that the variance in voxels outside the brain isn't entered into the regression model.
brainroipath = ['/fmri/data3/Evan/Gene-Rest-Nback/Analysis/ROI_analysis/Wholebrain_roi.mat'];
brainroi = maroi(brainroipath);

%location of Group ICA results
%Note that ICA components MUST be converted into ANALYZE format (via fslchfiletype)
componentpath = ['/fmri/data3/Evan/Gene-Rest-Nback/Analysis/ICA_lowthresh.gica/groupmelodic.ica/stats/thresh_zstat'];

%Prefix of preprocessed functional images
prefix = 'swa';

%location of SPM template file
SPM_analysistemplatefile = '/fmri/data3/Evan/Gene-Rest-Nback/Scripts/DualRegression_SPM_template.mat';

%TR in seconds
TR = 2;

%Microtime resolution and onset
MicroRes = 16;
MicroOnset = 1;

%--------------------------------------------------------------------------




%determine how many components were generated by FSL
componentnames = dir([componentpath '*.hdr']);
componentnames = componentnames(components_to_use);
numcomponents = length(componentnames);

%Put names of components, padded with spaces, into a matrix so that marsbar can run them all at once in the same space as a functional image
P = [];
for component = 1:numcomponents
    P = [P;sprintf('%-150s',[componentpath num2str(component) '.hdr'])];
end

warning off

%subject loop
for subnum = 1:length(subjects)
    subj = subjects{subnum};
    
    %User-specified stuff
    %--------------------------------------------------------------------------
    Rest_datafolder = ['/fmri/data3/Evan/Gene-Rest-Nback/Data/' subj '/Rest/'];
    Outputfolder = ['/fmri/data3/Evan/Gene-Rest-Nback/Analysis/' subj '/DualRegression_realcomps/'];
    %----------------------------------------------------------------------

    
    
    %1st regression: spatial
    %-----------------------------------------------------------------------
    
    %find functional data for this subject
    Imagesinfolder = dir([Rest_datafolder prefix '*.img']);
    num_timepoints = length(Imagesinfolder);

    %For the first subject, get the data within the wholebrain ROI for all the components, interpolated into same space as the functional images.
    %Then save that 3D data as a vector within a Designmatrix for each component, for later regression.
    %Note that you only need to do this for the first subject unless your subjects are in different spaces for some reason.
    if subnum == 1
        charactermat = [sprintf('%-150s',[Rest_datafolder Imagesinfolder(1).name]);P];
        Y = getdata(brainroi,charactermat,'l');
        Designmatrix = [Y(2:end,:)',ones(size(Y,2),1)];
    end

    timecourse = zeros(num_timepoints,1);
    %For each timepoint:
    for time = 1:num_timepoints
        disp(['Spatial regression: Subject ' subj ', timepoint ' num2str(time)])
        
        %Get subject's data within the ROI at that timepoint (the data is a vector)
        subjectdata = getdata(brainroi,[Rest_datafolder Imagesinfolder(time).name],'l');
        
        %Regress the data against all the components
        betavals = Designmatrix\(subjectdata');
        
        %Save the resulting beta values for that timepoint
        %These betas represent the strength/explanatory power of each group component at this timepoint
        timecourse(time,1:(length(betavals)-1)) = betavals(1:end-1)';
    end
    %-----------------------------------------------------------------------

    
    %2nd regression: temporal
    %-----------------------------------------------------------------------
    
    
    %load the template for the standard SPM temporal regression
    load(SPM_analysistemplatefile) 

    %Feed all the subject-specific info into the template
    for scan = 1:num_timepoints
        jobs{1}.stats{1}.fmri_spec.sess(1).scans{scan} = [Rest_datafolder Imagesinfolder(scan).name ',1'];;
    end
    
    jobs{1}.stats{1}.fmri_spec.timing.RT = TR;
    jobs{1}.stats{1}.fmri_spec.timing.fmri_t = MicroRes;
    jobs{1}.stats{1}.fmri_spec.timing.fmri_t0 = MicroOnset;
    
    jobs{1}.stats{1}.fmri_spec.dir{1} = Outputfolder;
    jobs{1}.stats{2}.fmri_est.spmmat{1} = [jobs{1}.stats{1}.fmri_spec.dir{1} 'SPM.mat'];
    jobs{1}.stats{3}.con.spmmat{1} = [jobs{1}.stats{1}.fmri_spec.dir{1} 'SPM.mat'];

    %make/clear directory for SPM data to be saved
    try;rmdir(jobs{1}.stats{1}.fmri_spec.dir{1},'s');catch;end
    mkdir(jobs{1}.stats{1}.fmri_spec.dir{1})

    
    %Put in the beta value timecourses as temporal regressors
    for component = 1:numcomponents
        jobs{1}.stats{1}.fmri_spec.sess.regress(component).val = timecourse(:,component);
        jobs{1}.stats{1}.fmri_spec.sess.regress(component).name = ['Component ' component];
    end
    
    %save the batch file for the temporal regression
    nameofSPMjob = [jobs{1}.stats{1}.fmri_spec.dir{1} '/DualRegression_batchjob.mat'];
    try delete(nameofSPMjob); catch; end
    save(nameofSPMjob, 'jobs', 'jobhelps');

    %Call SPM5 and run the temporal regression
    spm_jobman('run',nameofSPMjob)

    clear jobs
    %-----------------------------------------------------------------------
end


